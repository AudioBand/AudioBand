{
  "audioband/Windows11.html": {
    "href": "audioband/Windows11.html",
    "title": "Windows 11 Installation",
    "summary": "Windows 11 Installation The installation process is very similar to installing on Windows 10, and once installed, everything is the same as on Windows 10. In order for AudioBand to run properly, we have to patch the Taskbar using an external tool. Step 1: Patching The Taskbar There are 2 tools to achieve this, they're both super easy to install but they have some different functionalities. Information on these tools can be found at the bottom of this page if you're interested. If you just want to patch it, Download ExplorerPatcher and just run the install. Nothing else should be required. Note To change settings of the ExplorerPatcher, you just right click the Taskbar and click on Properties. Step 2: Installing AudioBand Now you just install AudioBand like you would before. Get the Latest Download and run it, and you're good to go. Extra Info: Taskbar Patchers If you'd like some more info on the choices of Taskbar Patchers, this is the place. There are two options, namely StartAllBack and ExplorerPatcher. A feature list can be found on the pages there. Normally, these apps are made by the same guy, the only difference is that ExplorerPatcher is FOSS (Free and Open Source Software) but it doesn't have all the functionality that StartAllBack has. However, StartAllBack is proprietary software."
  },
  "audioband/audiosources/index.html": {
    "href": "audioband/audiosources/index.html",
    "title": "Audio Sources",
    "summary": "Audio Sources Audio sources allow AudioBand to access data from different music players. To select an audio source, right click AudioBand and go to the AudioSources submenu. Check below for links on the specific audio source and setup instructions. Available audio sources Spotify iTunes MusicBee Windows 10 Audio source development"
  },
  "audioband/audiosources/itunes.html": {
    "href": "audioband/audiosources/itunes.html",
    "title": "iTunes",
    "summary": "iTunes No specific setup required for iTunes Note iTunes will open when the audio source is selected, and cannot be changed (as far as I know)."
  },
  "audioband/audiosources/musicbee.html": {
    "href": "audioband/audiosources/musicbee.html",
    "title": "MusicBee",
    "summary": "MusicBee Setup Make sure that the Musicbee IPC plugin is installed for MusicBee. Use this link if that link doesn't work."
  },
  "audioband/audiosources/spotify.html": {
    "href": "audioband/audiosources/spotify.html",
    "title": "Spotify",
    "summary": "Spotify Setup Login to the Spotify Dashboard and create a new App. Fill in the details, you can name it whatever you want. This app will be just for AudioBand. Go to the app you created and click Edit Settings. Add http://127.0.0.1/callback as a redirect url (see image below). If you use a different port than 80, you have to change the callback url to http://127.0.0.1:PORT/callback Right click anywhere in the toolbar -> Audio Band Settings -> Audio Source Settings and fill in the fields Spotify Client Id and Spotify Client Secret. You can find them in the same dashboard page for the Spotify app you created. Your browser should open asking you to login and allow your spotify app to access your currently playing songs. If your browser does not open automatically, Right click the toolbar and select Audio Sources > Spotify. It should now open in your default browser. Sign-in and accept and it should now display song information (make sure spotify is selected as the audio source). Note If you have premium, all controls will work (except for volume when playing on mobile devices (Spotify limitation)). Without premium, only play/pause, next and previous song will work. Dashboard Callback settings"
  },
  "audioband/audiosources/windows10.html": {
    "href": "audioband/audiosources/windows10.html",
    "title": "Windows 10",
    "summary": "Windows 10 No specific setup required for Windows 10 The Windows 10 AudioSource uses the SMTC API to control media on your desktop. Practically, anytime you can use your media keys to control any form of media, this AudioSource will work. Limitations Sadly, the SMTC API is still being developed and improved and is not a fine-tuned product yet, it also depends on the media sources to correctly implement these. Right Here you can find a list of tested out AudioSources which will/will not work with this AudioSource. Before filing a Bug Report saying that Windows10 AudioSource doesn't work, please check on The List first if it has full support. Note This will only work with apps who also have media hardware keys enabled. (eg. Using On-Keyboard key to pause/play music or fn + f-key on laptop.)"
  },
  "audioband/customization/albumartpopup.html": {
    "href": "audioband/customization/albumartpopup.html",
    "title": "Album Art Popup",
    "summary": "Album Art Popup Visibility Whether the popup will be visible Width Width of the popup Height Height of the popup X Position The x position of the popup. It is relative to the top left corner of the album art. Y Position The y position of the popup. It is relative to the top left corner of the album art."
  },
  "audioband/customization/general.html": {
    "href": "audioband/customization/general.html",
    "title": "General",
    "summary": "General Width The Width of the toolbar Height The Height of the toolbar"
  },
  "audioband/customization/index.html": {
    "href": "audioband/customization/index.html",
    "title": "Customization",
    "summary": "Customization Right click audio band and select Audio Band Settings and a new window will appear where you can do your customization. A description of the options can be found on this page and on the naviagtion on the left. In app help coming soon"
  },
  "audioband/customization/textlabels.html": {
    "href": "audioband/customization/textlabels.html",
    "title": "Text Labels",
    "summary": "Text Labels Name Name of the label. Used for indentification purposes Visibility Whether to show the label or not Width Width of the label. If the text exceeds the width, the text will scroll Height Height of the text X Position The x position of the text Y Position The Y Position of the text Font family The font family for the text Font size The font size of the text Font color The default color of the text Alignment The alignment of the label Scroll speed The scroll speed of the label when the text scrolls Text Format The text format for a label determines what text is shown It can be any combination of text or placeholders. For example the format This is some text will make the label display This is some text or Song name: {song} will display Song name: followed by whatever the current song's name is. The format for a placeholder is {style tag:color} where tag and color are any of the following values: Tag (case sensitive!) artist: Artist for the current song song: The title of the current song album: Album name for the current song time: Current playback time for the current song length: Total length of the current song remaining: Remaining time of the current song Color Use an html color code in the format #RRGGBB Text Style * (asterisk): Bolds the placeholder & (ampersand): Italicizes the placeholder _ (underline) - Underlines the placeholder Example formats Normal label showing the song and artist : {song} by {artist} Showing the album name in bold : {*album} Showing the song progress in gray : {time:#A9A9A9} : {length:#A9A9A9} Using style and color : {*artist:#a9a9a9}"
  },
  "audioband/development/create-button.html": {
    "href": "audioband/development/create-button.html",
    "title": "Development Guide: Creating a Button",
    "summary": "Development Guide: Creating a Button This guide will show you how to create a button for AudioBand, while this may not always be what you want to do, it's a good all-round example to see what AudioBand's structure looks like. Topic overview: Creating the button Updating the AudioSource functionality Creating the Button Model Adding the Button Model to the UserProfile (also update MigrationMappings) Adding the button visually inside of the Toolbar Creating and registering the Button's ViewModel Allowing customization of the button Creating the SettingsView inside of UI/PlaybackControls Adding the button to the SettingsWindow.xaml Warning When the settings will be revamped, doing the settings will change heavily. Creating the button 1. Updating the AudioSource functionality Every AudioSource, whether it's shipped with AudioBand or installed from a third party, adheres to the IAudioSource interface. This interface contains method signatures on how any AudioSource should implement anything from the Play Button to controlling the Volume. When you want to add a new button, you also have to create a new signature on how the feature of that button should behave. For a volume button, you need to set a signature like so: Task SetVolumeAsync(int newVolume);, so each AudioSource knows we handle volume as an integer from 0-100, and not a float from 0-1. It is good practise to update all existing AudioSources when you create such a new signature. If an AudioSource doesn't have a feature, just return empty. 2. Creating the Button Model The first step to creating a Button is to create a class inside of src/AudioBand/Models that inherits from the ButtonModelBase class. Take a look at PlayPauseButton / NextButton to see what exactly is needed inside of that class. You want to set IsVisible to false on these buttons, as it would otherwise mess up every existing profile there is (believe me I've made that mistake with an early release VolumeButton build). For each state of the button you want to add a ButtonContent property. This is by far the easiest way to handle it, as a lot will be handled for you automatically. In case you want to add extra properties, you can take a look at the VolumeButton Model, it added a whole customizable popup. 3. Adding the Button Model to the UserProfile (also update MigrationMappings) This part is very small, but quite important. The UserProfile class is the class that gets stored inside of the profile.json files. This is what will later allow it to be customizable. We need to add the new Button Model in there so people can customize it. People who update from a really old AudioBand build, can have an older version of settings (using TOML instead of JSON). To make sure they can still convert their old profiles into new ones, we also have to update the migrations that are in place. This is pretty easy to do, in src/AudioBand/Settings/MappingProfiles/SettingsV3ToSettingsV4Profile, copy VolumeButton's line, but replace it with your Button Model. 4. Creating and registering the Button's ViewModel This part requires a bit of copying, and then a bit of logic to actually implement the button. Depending on what kind of button is, this can get complex. The ViewModels are saved inside of the src/AudioBand/UI/PlaybackControls folder and need to inherit from the ButtonViewModelBase<MODELBUTTON> class. MODELBUTTON being your model made in step 2. Once you've made a ViewModel for your Button, copy the parameters from eg. VolumeButtonViewModel and create a private field for the IAppSettings and IAudioSession just like that class. You also need to copy over the OnEndEdit and the AppSettingsOnProfileChanged methods. Next up is the ButtonContentViewModels, for each ButtonContent you added inside of your Button Model earlier, you need to create a corresponding ButtonContentViewModel. You also need to initalize this/these just like in one of the other ViewModels. Last part of the creation part is to add a Command. I would like to explain what a command is but it's late at the time of writing, so I'm going to skip over the detailed explanation. But in short, a command is used to link a button click in the UI with logic in the backend. Take a look at the Command in the NextButtonViewModel and implement a similar Command in your ViewModel. The implementation of that command heavily depends on what your button is supposed to do, but usually it's a simple call to _audioSession.CurrentAudioSource.NewMethodFromStepOne(); Now for registering, you have to add it in src/AudioBand/Deskband.cs inside of the container. And then also add it to the (I)ViewModelContainer found in src/AudioBand/UI/ViewModel/"
  },
  "audioband/development/project-layout.html": {
    "href": "audioband/development/project-layout.html",
    "title": "Project layout",
    "summary": "Project layout Last commit at this time of writing / update: 33d68c84bd484d8b6f09bafcde2df08f2a853e23 Here are the main projects in the solution: AudioBand: The is the \"main\" project where audioband lives AudioBand.Logging: This project contains shared logging facilities AudioBand.AudioSource: This project contains the audiosource interface AudioBand.Test: This project contains Tests to test the functionality of AudioBand. AudioSourceHost: This project contains the assembly used to host an audio source in a separate app domain *AudioSource: These are the projects for the included audio sources. AudioBandInstaller: Can be ignored for most developers, this project handles creating the installer (.msi). AudioBand project Entry point The entry point for audioband can be found in the Deskband.cs file. This is the composition root of the application. It's the equivalent of the main function in a normal winforms or wpf application but instead of calling Application.Run(), the root user control is instantiated directly. There is no main window. The toolbar is implemented as a WPF usercontrol in UI/Toolbar/AudioBandToolbar.xaml AudioBandToolbar.xaml This is the top level user control, equivalent to the main window in wpf or main form in winforms. Codebehind The codebehind listens to size changes and notifies windows to update the deskband size. ViewModel The viewmodel for the toolbar can be found in ViewModels/AudioBandToolbarViewModel. It handles the context menu, loading the audio sources, and updating other view models when the audio source changes. When the toolbar is loaded, the LoadCommand is invoked, starting the step in initialization: loading the audio sources. Audio source loading Audio source loading is done by the AudioSource/AudioSourceManager class. Each audio source is loaded in their own app domain using the AudioSourceHost project. The creation and communication with the app domain is done through the AudioSource/AudioSourceProxy class. Currently, all audio sources are loaded at the start by the toolbar viewmodel, and there is no file system monitoring for new sources. For each audio source, these steps are performed: Add to the observable collection for the context menu Merge settings. If there are already saved settings for the audio source, then the settings are applied to the audio source If there are no previously saved settings, then the default setting values are extracted and saved Viewmodels for these settings are built and added so they can be manipulated in the settings window ui If the audio source is selected in the settings, then it is activated. App settings loading New Settings (v0.10 and upwards) The current settings use json to store information. The Settings/AppSettings is how the settings are opened up to the rest of the code, while Settings/Persistence/Settings is the Datatype that actual gets written/read by Settings/Persistence/PersistentSettings. You should avoid manually editing the settings files, and when writing code for AudioBand you should always make sure this is avoided. Old Settings (up until v0.9.10) Note The Old Settings description was written before the new settings system was in place. App settings are loaded and exposed by the Settings/AppSettings class. Persistence is done through Settings/Persistence/PersistSettings. The serialization format for settings uses the toml format. Toml is used because when the project was created, configuration was simple and editing the file in a text editor was the way to change settings. Toml was a good use case for that. Now, the settings have more nesting and more lists, which is less readable with toml however there is now a settings UI so editing the file isn't required. So migration to another serialization format isn't something required for now. Settings migrations Note Starting with the new system, migrations are no longer needed when adding settings (automatically handled). Though they are kept to allow older users to update with ease to the newest versions. As the settings evolve, the serialization format can change so there are settings migrations located in the Migrations subfolder. These classes update old configuration files to the latest format. If an older version of the settings is detected, then a lookup is done in SettingsMigration.cs to find the appropriate way to transform the settings file. Mapping is done with AutoMapper. Views and ViewModels Views and viewmodels are stored together in the UI subfolder. No MVVM frameworks are used, instead there is a ViewModelBase implementation and standard ICommand implementations. ViewModelBase provides automatic implementations for INotifyPropertyChanged: Has a SetProperty method that automatically calls INotifyPropertyChanged.PropertyChanged event if a field value changes. The attribute AlsoNotify can also be applied to raise PropertyChanged for other properties. Example: [AlsoNotify(nameof(Size))] public int Width { get => _width; set => SetProperty(ref _width, value); } public Size Size => new Size(Width, Height); INotifyDataError: Provides a few RaiseValidationError methods that raise the INotifyDataError.ErrorsChanged event. IResettable: Custom interface that exposes a method to reset the viewmodel to default values. The base class implements a command to call reset and the method ResetObject<T> to reset an object to its default value. BeginEdit,EndEdit and CancelEdit commands and methods. The attribute TrackState can is used to automatically call those methods. // Automatically calls BeginEdit method if the value is changed [TrackState] public int Width { get => Model.Width; // Using the model as the source for the value set => SetProperty(Model, nameof(Model.Width), value); // Set the value in the model } Message bus Under the Messages folder there is a simple IMessageBus interface. Messages are used sparingly for communicating between the Settings Window <-> Toolbar and between ViewModels. Other Dpi Since we are in an interop scenario, there are some issues with automatic dpi handling so it is done manually through the DpiScaling behavior located in the UI/behaviors folder. AudioSourceHost project The AudioSourceHost project is a library to load an audio source and exposes it via MarshalByRef objects for cross app domain communication. It uses the Microsoft Extensibility Framework to locate and load an IAudioSource."
  },
  "audioband/development/setup.html": {
    "href": "audioband/development/setup.html",
    "title": "",
    "summary": "Setup Install Visual Studio 2022. Make sure to install support for .Net Framework 4.8 development. Clone the repo https://github.com/AudioBand/AudioBand.git Open the solution file under src/AudioBand.sln in visual studio. Restore nuget packages before building The toolbar will have to be installed after being built (see Running local version section). Note Explorer does not unload audioband so you will not be able to build if explorer has loaded it. The debug configuration will automatically attempt close explorer to build the audioband project and restart it after the build. Running local version To test the local version of audioband, it needs to be installed as a toolbar. The easiest way is to copy the install script from tools/install.cmd to the build output folder (src/AudioBand/bin/Debug/) and run it as admin. Debugging There are 2 ways you can use a debugger on audioband. Attach the debugger: In visual studio, open the attach to process menu (ctrl + alt + p). Select explorer.exe and click attach. Inserting the statement System.Diagnostics.Debugger.Launch(); will allow you to attach a debugger at any place in the code. This is useful if you need the debugger at the start. Running unit tests You may notice that there is a configuration called Test. This is so that it is easier to run tests without having to restart explorer to build the project. Since the dlls will be in use by explorer, switching to the test configuration allows the project to be built. Otherwise, it should be identical to the debug configuration. Tests are located under the tests folder in the solution."
  },
  "audioband/development/wixproj.html": {
    "href": "audioband/development/wixproj.html",
    "title": "Compiling into an .msi",
    "summary": "Compiling into an .msi I'm writing this down for anyone who wants to make an .msi on their own, and for future me. You don't have to do this step if you want to test/run your local build. You only need this if you want to distribute your version. Requirements Wixtools Visual Studio Wixtools Visual Studio Extension Once Wixtools is installed it is recommended to add their root folder to your path. Compiling the .wixproj Once you have installed the Extension, you are now able to load in any .wixproj. If you did not add any AudioSources, it is pretty easy to compile. Set your environment to Release, and go to Build -> Build Solution. Once that is finished, you can Build the AudioBandInstaller project. You will find your .msi in src/AudioBandInstaller/bin/Release/. However, if you add a new AudioSource, you have to do some extra setup to make sure the .msi accounts for your new AudioSource. The steps aren't too hard though, just make sure you don't miss any: Run powershell.exe -File tools/patchinstaller.ps1 MAJOR_VERSION MINOR_VERSION PATCH_VERSION from the root of the folder Add YourAudioSourcePath as a constant to the <DefineConstants> tag inside of .wixproj Add a <HeatDirectory> tag inside of .wixproj for your AudioSource Add a project reference to your AudioSource Add a <Feature> tag inside of Product.wxs for your AudioSource The XXXHeatGenerated.wxs files you see should be automatically generated, if not, also run while inside your AudioSource folder: heat project XXXAudioSource.csproj -ag -pog Binaries -template fragment -out ../AudioBandInstaller/XXXHeatGenerated.wxs From what I understand, Heating Files is just a way to tell the project where to get all the correct files from."
  },
  "audioband/faq.html": {
    "href": "audioband/faq.html",
    "title": "FAQ",
    "summary": "FAQ Q. Why is there a margin on the right of the toolbar? This occurs if you've moved the toolbar, then lock the task bar. Restarting explorer should get rid of the margin"
  },
  "audioband/index.html": {
    "href": "audioband/index.html",
    "title": "Audioband Documentation",
    "summary": "Audioband Documentation Welcome to the documentation pages! On the left you will find more pages with more in-depth information. For a basic installation, see this page. CLICK HERE FOR WINDOWS 11 INSTALLATION Quick Start Requirements .Net framework 4.7 Windows 10 Installation Download the Latest Release and run the .msi. Follow the instructions on the screen. Usage Right click on the Taskbar, go to the Toolbars drop-out and select Audio Band. Right click on the Audio Band Toolbar and select an audio source (eg. Windows10). Do any audio source specific setup. Spotify, for example requires some additional setup. Important Previous versions of Windows are not supported. Audioband may still work but it has not been tested. Note High DPI is supported on Windows 10 1703 and above. Info Logs can be found in the temp folder: %temp%\\AudioBand.log Settings are saved in the app data directory: %appdata%\\AudioBand"
  },
  "audiosource-api/index.html": {
    "href": "audiosource-api/index.html",
    "title": "AudioSource api reference",
    "summary": "AudioSource api reference"
  },
  "audiosource-docs/index.html": {
    "href": "audiosource-docs/index.html",
    "title": "AudioSource development",
    "summary": "AudioSource development This page contains the AudioBand.AudioSource api documentation and documentation on developing an audio source for AudioBand. Building a new audio source project Create a new class library project Install the audio source nuget package Create a class to implement IAudioSource. Api reference on the right. public class AudioSource : IAudioSource { // implementation here } The file AudioSource.manifest should be add to the project after installing the nuget package. Edit the file so that the name will matches your asembly file name. AudioSource = \"AudioSource.dll\" Developing In order to get it functional, you have to implement every function of IAudioSource. You can find out what they do by hovering over them in your IDE, it will show what the function is used for. (You can also reference Dsafa's API refence because I don't know how to setup my own.) You can also utilize the existing ones in the Main AudioBand Repo as a template or guiding line. If you have any questions, feel free to contact me on our Discord Server or on GitHub through an issue. Deploying your new audio source. (Hopefully) coming soon: An in-app way to download/install/distribute your custom audiosource via This GitHub repo. For now, AudioBand reads each sub folder under the AudioSources folder. To deploy your new audio source, place your files under a new subfolder in the AudioSources directory. Ensure that your AudioSource.manifest file is also included. You also do not need to copy the AudioBand.AudioSource library files The file structure will look like this: Audioband/ |--AudioSources/ |--NewAudioSource/ |--Audiosource.dll |--AudioSource.manifest |--other files"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the AudioBand documentation homepage.",
    "summary": "Welcome to the AudioBand documentation homepage. Refer to the links below to get started. Links AudioBand help and documentation Documentation for implementing an audiosource"
  }
}